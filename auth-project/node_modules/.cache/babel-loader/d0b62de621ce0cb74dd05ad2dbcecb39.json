{"ast":null,"code":"import React, { useContext } from 'react';\nimport { randomBytes, createHash } from 'crypto';\nimport jwtDecode from 'jwt-decode';\nvar AuthContext = React.createContext(undefined);\n\nvar useAuth = function useAuth() {\n  var context = useContext(AuthContext);\n\n  if (context === undefined) {\n    throw new Error('useAuth must be used within a AuthProvider');\n  }\n\n  return context;\n};\n\nfunction withAuth(ComponentToWrap) {\n  var WrappedComponent = function WrappedComponent(props) {\n    var authProps = useAuth();\n    return React.createElement(ComponentToWrap, Object.assign({}, authProps, props));\n  };\n\n  WrappedComponent.displayName = 'withAuth_' + (ComponentToWrap.displayName || ComponentToWrap.name);\n  return WrappedComponent;\n}\n\nvar AuthProvider = function AuthProvider(props) {\n  var authService = props.authService,\n      children = props.children;\n  return React.createElement(AuthContext.Provider, {\n    value: {\n      authService: authService\n    }\n  }, children);\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o) {\n  var i = 0;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n}\n\nvar base64URLEncode = function base64URLEncode(str) {\n  return str.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n};\n\nvar sha256 = function sha256(buffer) {\n  return createHash('sha256').update(buffer).digest();\n};\n\nvar createPKCECodes = function createPKCECodes() {\n  var codeVerifier = base64URLEncode(randomBytes(64));\n  var codeChallenge = base64URLEncode(sha256(Buffer.from(codeVerifier)));\n  var createdAt = new Date();\n  var codePair = {\n    codeVerifier: codeVerifier,\n    codeChallenge: codeChallenge,\n    createdAt: createdAt\n  };\n  return codePair;\n};\n\nvar toSnakeCase = function toSnakeCase(str) {\n  return str.split(/(?=[A-Z])/).join('_').toLowerCase();\n};\n\nvar toUrlEncoded = function toUrlEncoded(obj) {\n  return Object.keys(obj).map(function (k) {\n    return encodeURIComponent(toSnakeCase(k)) + '=' + encodeURIComponent(obj[k]);\n  }).join('&');\n};\n\nvar AuthService = /*#__PURE__*/function () {\n  function AuthService(props) {\n    var _this = this;\n\n    this.props = props;\n    var code = this.getCodeFromLocation(window.location);\n\n    if (code !== null) {\n      this.fetchToken(code).then(function () {\n        _this.restoreUri();\n      })[\"catch\"](function (e) {\n        _this.removeItem('pkce');\n\n        _this.removeItem('auth');\n\n        _this.removeCodeFromLocation();\n\n        console.warn({\n          e: e\n        });\n      });\n    } else if (this.props.autoRefresh) {\n      this.startTimer();\n    }\n  }\n\n  var _proto = AuthService.prototype;\n\n  _proto.getUser = function getUser() {\n    var t = this.getAuthTokens();\n    if (null === t) return {};\n    var decoded = jwtDecode(t.id_token);\n    return decoded;\n  };\n\n  _proto.getCodeFromLocation = function getCodeFromLocation(location) {\n    var split = location.toString().split('?');\n\n    if (split.length < 2) {\n      return null;\n    }\n\n    var pairs = split[1].split('&');\n\n    for (var _iterator = _createForOfIteratorHelperLoose(pairs), _step; !(_step = _iterator()).done;) {\n      var pair = _step.value;\n\n      var _pair$split = pair.split('='),\n          key = _pair$split[0],\n          value = _pair$split[1];\n\n      if (key === 'code') {\n        return decodeURIComponent(value || '');\n      }\n    }\n\n    return null;\n  };\n\n  _proto.removeCodeFromLocation = function removeCodeFromLocation() {\n    var _window$location$href = window.location.href.split('?'),\n        base = _window$location$href[0],\n        search = _window$location$href[1];\n\n    if (!search) {\n      return;\n    }\n\n    var newSearch = search.split('&').map(function (param) {\n      return param.split('=');\n    }).filter(function (_ref) {\n      var key = _ref[0];\n      return key !== 'code';\n    }).map(function (keyAndVal) {\n      return keyAndVal.join('=');\n    }).join('&');\n    window.history.replaceState(window.history.state, 'null', base + (newSearch.length ? \"?\" + newSearch : ''));\n  };\n\n  _proto.getItem = function getItem(key) {\n    return window.localStorage.getItem(key);\n  };\n\n  _proto.removeItem = function removeItem(key) {\n    window.localStorage.removeItem(key);\n  };\n\n  _proto.getPkce = function getPkce() {\n    var pkce = window.localStorage.getItem('pkce');\n\n    if (null === pkce) {\n      throw new Error('PKCE pair not found in local storage');\n    } else {\n      return JSON.parse(pkce);\n    }\n  };\n\n  _proto.setAuthTokens = function setAuthTokens(auth) {\n    var _this$props$refreshSl = this.props.refreshSlack,\n        refreshSlack = _this$props$refreshSl === void 0 ? 5 : _this$props$refreshSl;\n    var now = new Date().getTime();\n    auth.expires_at = now + (auth.expires_in + refreshSlack) * 1000;\n    window.localStorage.setItem('auth', JSON.stringify(auth));\n  };\n\n  _proto.getAuthTokens = function getAuthTokens() {\n    return JSON.parse(window.localStorage.getItem('auth') || '{}');\n  };\n\n  _proto.isPending = function isPending() {\n    return window.localStorage.getItem('pkce') !== null && window.localStorage.getItem('auth') === null;\n  };\n\n  _proto.isAuthenticated = function isAuthenticated() {\n    return window.localStorage.getItem('auth') !== null;\n  };\n\n  _proto.logout = function logout(shouldEndSession) {\n    if (shouldEndSession === void 0) {\n      shouldEndSession = false;\n    }\n\n    try {\n      var _this3 = this;\n\n      _this3.removeItem('pkce');\n\n      _this3.removeItem('auth');\n\n      if (shouldEndSession) {\n        var _this3$props = _this3.props,\n            clientId = _this3$props.clientId,\n            provider = _this3$props.provider,\n            logoutEndpoint = _this3$props.logoutEndpoint,\n            redirectUri = _this3$props.redirectUri;\n        var query = {\n          client_id: clientId,\n          post_logout_redirect_uri: redirectUri\n        };\n        var url = (logoutEndpoint || provider + \"/logout\") + \"?\" + toUrlEncoded(query);\n        window.location.replace(url);\n        return Promise.resolve(true);\n      } else {\n        window.location.reload();\n        return Promise.resolve(true);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.login = function login() {\n    try {\n      var _this5 = this;\n\n      _this5.authorize();\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.authorize = function authorize() {\n    var _this$props = this.props,\n        clientId = _this$props.clientId,\n        provider = _this$props.provider,\n        authorizeEndpoint = _this$props.authorizeEndpoint,\n        redirectUri = _this$props.redirectUri,\n        scopes = _this$props.scopes,\n        audience = _this$props.audience;\n    var pkce = createPKCECodes();\n    window.localStorage.setItem('pkce', JSON.stringify(pkce));\n    window.localStorage.setItem('preAuthUri', location.href);\n    window.localStorage.removeItem('auth');\n    var codeChallenge = pkce.codeChallenge;\n\n    var query = _extends(_extends({\n      clientId: clientId,\n      scope: scopes.join(' '),\n      responseType: 'code',\n      redirectUri: redirectUri\n    }, audience && {\n      audience: audience\n    }), {}, {\n      codeChallenge: codeChallenge,\n      codeChallengeMethod: 'S256'\n    });\n\n    var url = (authorizeEndpoint || provider + \"/authorize\") + \"?\" + toUrlEncoded(query);\n    window.location.replace(url);\n    return true;\n  };\n\n  _proto.fetchToken = function fetchToken(code, isRefresh) {\n    if (isRefresh === void 0) {\n      isRefresh = false;\n    }\n\n    try {\n      var _this7 = this;\n\n      var _this7$props = _this7.props,\n          clientId = _this7$props.clientId,\n          clientSecret = _this7$props.clientSecret,\n          contentType = _this7$props.contentType,\n          provider = _this7$props.provider,\n          tokenEndpoint = _this7$props.tokenEndpoint,\n          redirectUri = _this7$props.redirectUri,\n          _this7$props$autoRefr = _this7$props.autoRefresh,\n          autoRefresh = _this7$props$autoRefr === void 0 ? true : _this7$props$autoRefr;\n      var grantType = 'authorization_code';\n\n      var payload = _extends(_extends({\n        clientId: clientId\n      }, clientSecret ? {\n        clientSecret: clientSecret\n      } : {}), {}, {\n        redirectUri: redirectUri,\n        grantType: grantType\n      });\n\n      if (isRefresh) {\n        payload = _extends(_extends({}, payload), {}, {\n          grantType: 'refresh_token',\n          refresh_token: code\n        });\n      } else {\n        var pkce = _this7.getPkce();\n\n        var codeVerifier = pkce.codeVerifier;\n        payload = _extends(_extends({}, payload), {}, {\n          code: code,\n          codeVerifier: codeVerifier\n        });\n      }\n\n      return Promise.resolve(fetch(\"\" + (tokenEndpoint || provider + \"/token\"), {\n        headers: {\n          'Content-Type': contentType || 'application/x-www-form-urlencoded'\n        },\n        method: 'POST',\n        body: toUrlEncoded(payload)\n      })).then(function (response) {\n        _this7.removeItem('pkce');\n\n        return Promise.resolve(response.json()).then(function (json) {\n          if (isRefresh && !json.refresh_token) {\n            json.refresh_token = payload.refresh_token;\n          }\n\n          _this7.setAuthTokens(json);\n\n          if (autoRefresh) {\n            _this7.startTimer();\n          }\n\n          return _this7.getAuthTokens();\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.armRefreshTimer = function armRefreshTimer(refreshToken, timeoutDuration) {\n    var _this8 = this;\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n\n    this.timeout = window.setTimeout(function () {\n      _this8.fetchToken(refreshToken, true).then(function (_ref2) {\n        var newRefreshToken = _ref2.refresh_token,\n            expiresAt = _ref2.expires_at;\n        if (!expiresAt) return;\n        var now = new Date().getTime();\n        var timeout = expiresAt - now;\n\n        if (timeout > 0) {\n          _this8.armRefreshTimer(newRefreshToken, timeout);\n        } else {\n          _this8.removeItem('auth');\n\n          _this8.removeCodeFromLocation();\n        }\n      })[\"catch\"](function (e) {\n        _this8.removeItem('auth');\n\n        _this8.removeCodeFromLocation();\n\n        console.warn({\n          e: e\n        });\n      });\n    }, timeoutDuration);\n  };\n\n  _proto.startTimer = function startTimer() {\n    var authTokens = this.getAuthTokens();\n\n    if (!authTokens) {\n      return;\n    }\n\n    var refreshToken = authTokens.refresh_token,\n        expiresAt = authTokens.expires_at;\n\n    if (!expiresAt || !refreshToken) {\n      return;\n    }\n\n    var now = new Date().getTime();\n    var timeout = expiresAt - now;\n\n    if (timeout > 0) {\n      this.armRefreshTimer(refreshToken, timeout);\n    } else {\n      this.removeItem('auth');\n      this.removeCodeFromLocation();\n    }\n  };\n\n  _proto.restoreUri = function restoreUri() {\n    var uri = window.localStorage.getItem('preAuthUri');\n    window.localStorage.removeItem('preAuthUri');\n    console.log({\n      uri: uri\n    });\n\n    if (uri !== null) {\n      window.location.replace(uri);\n    }\n\n    this.removeCodeFromLocation();\n  };\n\n  return AuthService;\n}();\n\nexport { AuthContext, AuthProvider, AuthService, useAuth, withAuth };","map":{"version":3,"mappings":";;;IAUaA,WAAW,GAAGC,KAAK,CAACC,aAAND,CACzBE,SADyBF;;IAIdG,OAAO,GAAG,SAAVA,OAAU;EACrB,IAAMC,OAAO,GAAGC,UAAU,CAACN,WAAD,CAA1B;;EACA,IAAIK,OAAO,KAAKF,SAAhB,EAA2B;IACzB,MAAM,IAAII,KAAJ,CAAU,4CAAV,CAAN;EACD;;EACD,OAAOF,OAAP;AACD;;SAEeG,SACdC;EAEA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,KAAD;IACvB,IAAMC,SAAS,GAAGR,OAAO,EAAzB;IACA,OAAOH,oBAACQ,eAADR,oBAAqBW,SAArB,EAAoCD,KAApC,EAAP;EAFF;;EAIAD,gBAAgB,CAACG,WAAjBH,GACE,eAAeD,eAAe,CAACI,WAAhBJ,IAA+BA,eAAe,CAACK,IAA9D,CADFJ;EAEA,OAAOA,gBAAP;AACD;;ICtBYK,YAAY,GAAG,SAAfA,YAAe,CAACJ,KAAD;MAClBK,cAA0BL,MAA1BK;MAAaC,WAAaN,MAAbM;EAErB,OACEhB,oBAACD,WAAW,CAACkB,QAAbjB;IAAsBkB,KAAK,EAAE;MAAEH,WAAW,EAAXA;IAAF;EAA7B,GACGC,QADHhB,CADF;AAHK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA,IAAMmB,eAAe,GAAG,SAAlBA,eAAkB,CAACC,GAAD;EAC7B,OAAOA,GAAG,CACPC,QADID,CACK,QADLA,EAEJE,OAFIF,CAEI,KAFJA,EAEW,GAFXA,EAGJE,OAHIF,CAGI,KAHJA,EAGW,GAHXA,EAIJE,OAJIF,CAII,IAJJA,EAIU,EAJVA,CAAP;AADK;;AAQP,IAAaG,MAAM,GAAG,SAATA,MAAS,CAACC,MAAD;EACpB,OAAOC,UAAU,CAAC,QAAD,CAAVA,CAAqBC,MAArBD,CAA4BD,MAA5BC,EAAoCE,MAApCF,EAAP;AADK,CAAP;;AAIA,IAAaG,eAAe,GAAG,SAAlBA,eAAkB;EAC7B,IAAMC,YAAY,GAAGV,eAAe,CAACW,WAAW,CAAC,EAAD,CAAZ,CAApC;EACA,IAAMC,aAAa,GAAGZ,eAAe,CAACI,MAAM,CAACS,MAAM,CAACC,IAAPD,CAAYH,YAAZG,CAAD,CAAP,CAArC;EACA,IAAME,SAAS,GAAG,IAAIC,IAAJ,EAAlB;EACA,IAAMC,QAAQ,GAAG;IACfP,YAAY,EAAZA,YADe;IAEfE,aAAa,EAAbA,aAFe;IAGfG,SAAS,EAATA;EAHe,CAAjB;EAKA,OAAOE,QAAP;AATK,CAAP;;ACpBO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACjB,GAAD;EACzB,OAAOA,GAAG,CACPkB,KADIlB,CACE,WADFA,EAEJmB,IAFInB,CAEC,GAFDA,EAGJoB,WAHIpB,EAAP;AADK;;AAOP,IAAaqB,YAAY,GAAG,SAAfA,YAAe,CAACC,GAAD;EAC1B,OAAOC,MAAM,CAACC,IAAPD,CAAYD,GAAZC,EACJE,GADIF,CAEH,UAACG,CAAD;IAAA,OACEC,kBAAkB,CAACV,WAAW,CAACS,CAAD,CAAZ,CAAlBC,GAAqC,GAArCA,GAA2CA,kBAAkB,CAACL,GAAG,CAACI,CAAD,CAAJ,CAD/D;EAFG,GAKJP,IALII,CAKC,GALDA,CAAP;AADK,CAAP;;ICyCaK,WAAb;EAIE,qBAAYtC,KAAZ;;;IACE,KAAKA,KAAL,GAAaA,KAAb;IACA,IAAMuC,IAAI,GAAG,KAAKC,mBAAL,CAAyBC,MAAM,CAACC,QAAhC,CAAb;;IACA,IAAIH,IAAI,KAAK,IAAb,EAAmB;MACjB,KAAKI,UAAL,CAAgBJ,IAAhB,EACGK,IADH,CACQ;QACJC,KAAI,CAACC,UAAL;MAFJ,YAIS,UAACC,CAAD;QACLF,KAAI,CAACG,UAAL,CAAgB,MAAhB;;QACAH,KAAI,CAACG,UAAL,CAAgB,MAAhB;;QACAH,KAAI,CAACI,sBAAL;;QACAC,OAAO,CAACC,IAARD,CAAa;UAAEH,CAAC,EAADA;QAAF,CAAbG;MARJ;IADF,OAWO,IAAI,KAAKlD,KAAL,CAAWoD,WAAf,EAA4B;MACjC,KAAKC,UAAL;IACD;EACF;;EArBH;;EAAAC,OAuBEC,OAvBF,GAuBE;IACE,IAAMC,CAAC,GAAG,KAAKC,aAAL,EAAV;IACA,IAAI,SAASD,CAAb,EAAgB,OAAO,EAAP;IAChB,IAAME,OAAO,GAAGC,SAAS,CAACH,CAAC,CAACI,QAAH,CAAzB;IACA,OAAOF,OAAP;EA3BJ;;EAAAJ,OA8BEd,mBA9BF,GA8BE,6BAAoBE,QAApB;IACE,IAAMd,KAAK,GAAGc,QAAQ,CAAC/B,QAAT+B,GAAoBd,KAApBc,CAA0B,GAA1BA,CAAd;;IACA,IAAId,KAAK,CAACiC,MAANjC,GAAe,CAAnB,EAAsB;MACpB,OAAO,IAAP;IACD;;IACD,IAAMkC,KAAK,GAAGlC,KAAK,CAAC,CAAD,CAALA,CAASA,KAATA,CAAe,GAAfA,CAAd;;IACA,qDAAmBkC,KAAnB,wCAA0B;MAAA,IAAfC,IAAe;;MAAA,kBACHA,IAAI,CAACnC,KAALmC,CAAW,GAAXA,CADG;MAAA,IACjBC,GADiB;MAAA,IACZxD,KADY;;MAExB,IAAIwD,GAAG,KAAK,MAAZ,EAAoB;QAClB,OAAOC,kBAAkB,CAACzD,KAAK,IAAI,EAAV,CAAzB;MACD;IACF;;IACD,OAAO,IAAP;EA1CJ;;EAAA8C,OA6CEL,sBA7CF,GA6CE;gCACyBR,MAAM,CAACC,QAAPD,CAAgByB,IAAhBzB,CAAqBb,KAArBa,CAA2B,GAA3BA;QAAhB0B;QAAMC;;IACb,IAAI,CAACA,MAAL,EAAa;MACX;IACD;;IACD,IAAMC,SAAS,GAAGD,MAAM,CACrBxC,KADewC,CACT,GADSA,EAEfjC,GAFeiC,CAEX,UAACE,KAAD;MAAA,OAAWA,KAAK,CAAC1C,KAAN0C,CAAY,GAAZA,CAAX;IAFW,GAGfC,MAHeH,CAGR;MAAA,IAAEJ,GAAF;MAAA,OAAWA,GAAG,KAAK,MAAnB;IAHQ,GAIf7B,GAJeiC,CAIX,UAACI,SAAD;MAAA,OAAeA,SAAS,CAAC3C,IAAV2C,CAAe,GAAfA,CAAf;IAJW,GAKf3C,IALeuC,CAKV,GALUA,CAAlB;IAMA3B,MAAM,CAACgC,OAAPhC,CAAeiC,YAAfjC,CACEA,MAAM,CAACgC,OAAPhC,CAAekC,KADjBlC,EAEE,MAFFA,EAGE0B,IAAI,IAAIE,SAAS,CAACR,MAAVQ,SAAuBA,SAAvBA,GAAqC,EAAzC,CAHN5B;EAxDJ;;EAAAa,OA+DEsB,OA/DF,GA+DE,iBAAQZ,GAAR;IACE,OAAOvB,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4BuB,GAA5BvB,CAAP;EAhEJ;;EAAAa,OAkEEN,UAlEF,GAkEE,oBAAWgB,GAAX;IACEvB,MAAM,CAACoC,YAAPpC,CAAoBO,UAApBP,CAA+BuB,GAA/BvB;EAnEJ;;EAAAa,OAsEEwB,OAtEF,GAsEE;IACE,IAAMC,IAAI,GAAGtC,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,MAA5BA,CAAb;;IACA,IAAI,SAASsC,IAAb,EAAmB;MACjB,MAAM,IAAInF,KAAJ,CAAU,sCAAV,CAAN;IADF,OAEO;MACL,OAAOoF,IAAI,CAACC,KAALD,CAAWD,IAAXC,CAAP;IACD;EA5EL;;EAAA1B,OA+EE4B,aA/EF,GA+EE,uBAAcC,IAAd;gCAC+B,KAAKnF,KAAL,CAArBoF;QAAAA,kDAAe,CAAfA,GAAeC;IACvB,IAAMC,GAAG,GAAG,IAAI7D,IAAJ,GAAW8D,OAAX,EAAZ;IACAJ,IAAI,CAACK,UAALL,GAAkBG,GAAG,GAAG,CAACH,IAAI,CAACM,UAALN,GAAkBC,YAAnB,IAAmC,IAA3DD;IACA1C,MAAM,CAACoC,YAAPpC,CAAoBiD,OAApBjD,CAA4B,MAA5BA,EAAoCuC,IAAI,CAACW,SAALX,CAAeG,IAAfH,CAApCvC;EAnFJ;;EAAAa,OAsFEG,aAtFF,GAsFE;IACE,OAAOuB,IAAI,CAACC,KAALD,CAAWvC,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,MAA5BA,KAAuC,IAAlDuC,CAAP;EAvFJ;;EAAA1B,OA0FEsC,SA1FF,GA0FE;IACE,OACEnD,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,MAA5BA,MAAwC,IAAxCA,IACAA,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,MAA5BA,MAAwC,IAF1C;EA3FJ;;EAAAa,OAiGEuC,eAjGF,GAiGE;IACE,OAAOpD,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,MAA5BA,MAAwC,IAA/C;EAlGJ;;EAAAa,OAqGQwC,MArGR,mBAqGeC,gBArGf;IAAA,IAqGeA,gBArGf;MAqGeA,gBArGf,GAqG2C,KAA5BA;IArGf;;IAAA;mBAsGI;;MAAAC,OAAKhD,UAAL,CAAgB,MAAhB;;MACAgD,OAAKhD,UAAL,CAAgB,MAAhB;;MACA,IAAI+C,gBAAJ,EAAsB;QAAA,mBACwCC,OAAKhG,KAD7C;QAAA,IACZiG,QADY,gBACZA,QADY;QAAA,IACFC,QADE,gBACFA,QADE;QAAA,IACQC,cADR,gBACQA,cADR;QAAA,IACwBC,WADxB,gBACwBA,WADxB;QAEpB,IAAMC,KAAK,GAAG;UACZC,SAAS,EAAEL,QADC;UAEZM,wBAAwB,EAAEH;QAFd,CAAd;QAIA,IAAMI,GAAG,IAAML,cAAc,IAAOD,QAAP,YAApB,UAAgDnE,YAAY,CAACsE,KAAD,CAArE;QACA5D,MAAM,CAACC,QAAPD,CAAgB7B,OAAhB6B,CAAwB+D,GAAxB/D;QACA,uBAAO,IAAP;MARF,OASO;QACLA,MAAM,CAACC,QAAPD,CAAgBgE,MAAhBhE;QACA,uBAAO,IAAP;MACD;IApHL;MAAA;IAAA;EAAA;;EAAAa,OAuHQoD,KAvHR;IAAA;mBAwHI;;MAAAC,OAAKC,SAAL;;;IAxHJ;MAAA;IAAA;EAAA;;EAAAtD,OA4HEsD,SA5HF,GA4HE;sBACmF,KAAK5G;QAA9EiG;QAAUC;QAAUW;QAAmBT;QAAaU;QAAQC;IAEpE,IAAMhC,IAAI,GAAG7D,eAAe,EAA5B;IACAuB,MAAM,CAACoC,YAAPpC,CAAoBiD,OAApBjD,CAA4B,MAA5BA,EAAoCuC,IAAI,CAACW,SAALX,CAAeD,IAAfC,CAApCvC;IACAA,MAAM,CAACoC,YAAPpC,CAAoBiD,OAApBjD,CAA4B,YAA5BA,EAA0CC,QAAQ,CAACwB,IAAnDzB;IACAA,MAAM,CAACoC,YAAPpC,CAAoBO,UAApBP,CAA+B,MAA/BA;IACA,IAAMpB,aAAa,GAAG0D,IAAI,CAAC1D,aAA3B;;IAEA,IAAMgF,KAAK;MACTJ,QAAQ,EAARA,QADS;MAETe,KAAK,EAAEF,MAAM,CAACjF,IAAPiF,CAAY,GAAZA,CAFE;MAGTG,YAAY,EAAE,MAHL;MAITb,WAAW,EAAXA;IAJS,GAKLW,QAAQ,IAAI;MAAEA,QAAQ,EAARA;IAAF,CALP;MAMT1F,aAAa,EAAbA,aANS;MAOT6F,mBAAmB,EAAE;IAPZ,EAAX;;IAUA,IAAMV,GAAG,IAAMK,iBAAiB,IAAOX,QAAP,eAAvB,UAAsDnE,YAAY,CAACsE,KAAD,CAA3E;IACA5D,MAAM,CAACC,QAAPD,CAAgB7B,OAAhB6B,CAAwB+D,GAAxB/D;IACA,OAAO,IAAP;EAjJJ;;EAAAa,OAqJQX,UArJR,uBAqJmBJ,IArJnB,EAqJiC4E,SArJjC;IAAA,IAqJiCA,SArJjC;MAqJiCA,SArJjC,GAqJ6C,KAAZA;IArJjC;;IAAA;mBA8JQ;;yBAAAC,OAAKpH;UAPPiG;UACAoB;UACAC;UACApB;UACAqB;UACAnB;+CACAhD;UAAAA,iDAAc,IAAdA,GAAcoE;MAEhB,IAAMC,SAAS,GAAG,oBAAlB;;MAEA,IAAIC,OAAO;QACTzB,QAAQ,EAARA;MADS,GAELoB,YAAY,GAAG;QAAEA,YAAY,EAAZA;MAAF,CAAH,GAAsB,EAF7B;QAGTjB,WAAW,EAAXA,WAHS;QAITqB,SAAS,EAATA;MAJS,EAAX;;MAMA,IAAIN,SAAJ,EAAe;QACbO,OAAO,yBACFA,OADE;UAELD,SAAS,EAAE,eAFN;UAGLE,aAAa,EAAEpF;QAHV,EAAPmF;MADF,OAMO;QACL,IAAM3C,IAAI,GAAiBqC,OAAKtC,OAAL,EAA3B;;QACA,IAAM3D,YAAY,GAAG4D,IAAI,CAAC5D,YAA1B;QACAuG,OAAO,yBACFA,OADE;UAELnF,IAAI,EAAJA,IAFK;UAGLpB,YAAY,EAAZA;QAHK,EAAPuG;MAKD;;6BAEsBE,KAAK,OAAIL,aAAa,IAAOrB,QAAP,WAAjB,GAA4C;QACtE2B,OAAO,EAAE;UACP,gBAAgBP,WAAW,IAAI;QADxB,CAD6D;QAItEQ,MAAM,EAAE,MAJ8D;QAKtEC,IAAI,EAAEhG,YAAY,CAAC2F,OAAD;MALoD,CAA5C,kBAAtBM,QAAsB,EAAtBA;QAONZ,OAAKpE,UAAL,CAAgB,MAAhB;;+BACiBgF,QAAQ,CAACC,IAATD,mBAAbC,IAAa,EAAbA;UACJ,IAAId,SAAS,IAAI,CAACc,IAAI,CAACN,aAAvB,EAAsC;YACpCM,IAAI,CAACN,aAALM,GAAqBP,OAAO,CAACC,aAA7BM;UACD;;UACDb,OAAKlC,aAAL,CAAmB+C,IAAnB;;UACA,IAAI7E,WAAJ,EAAiB;YACfgE,OAAK/D,UAAL;UACD;;UACD,OAAO+D,OAAK3D,aAAL,EAAP;;;IAvMJ;MAAA;IAAA;EAAA;;EAAAH,OA0ME4E,eA1MF,GA0ME,yBAAgBC,YAAhB,EAAsCC,eAAtC;;;IACE,IAAI,KAAKC,OAAT,EAAkB;MAChBC,YAAY,CAAC,KAAKD,OAAN,CAAZC;IACD;;IACD,KAAKD,OAAL,GAAe5F,MAAM,CAAC8F,UAAP9F,CAAkB;MAC/B+F,MAAI,CAAC7F,UAAL,CAAgBwF,YAAhB,EAA8B,IAA9B,EACGvF,IADH,CACQ;YAAkB6F,wBAAfd;YAA4Ce,kBAAZlD;QACvC,IAAI,CAACkD,SAAL,EAAgB;QAChB,IAAMpD,GAAG,GAAG,IAAI7D,IAAJ,GAAW8D,OAAX,EAAZ;QACA,IAAM8C,OAAO,GAAGK,SAAS,GAAGpD,GAA5B;;QACA,IAAI+C,OAAO,GAAG,CAAd,EAAiB;UACfG,MAAI,CAACN,eAAL,CAAqBO,eAArB,EAAsCJ,OAAtC;QADF,OAEO;UACLG,MAAI,CAACxF,UAAL,CAAgB,MAAhB;;UACAwF,MAAI,CAACvF,sBAAL;QACD;MAVL,YAYS,UAACF,CAAD;QACLyF,MAAI,CAACxF,UAAL,CAAgB,MAAhB;;QACAwF,MAAI,CAACvF,sBAAL;;QACAC,OAAO,CAACC,IAARD,CAAa;UAAEH,CAAC,EAADA;QAAF,CAAbG;MAfJ;IADa,GAkBZkF,eAlBY3F,CAAf;EA9MJ;;EAAAa,OAmOED,UAnOF,GAmOE;IACE,IAAMsF,UAAU,GAAG,KAAKlF,aAAL,EAAnB;;IACA,IAAI,CAACkF,UAAL,EAAiB;MACf;IACD;;QACsBR,eAAwCQ,WAAvDhB;QAAyCe,YAAcC,WAA1BnD;;IACrC,IAAI,CAACkD,SAAD,IAAc,CAACP,YAAnB,EAAiC;MAC/B;IACD;;IACD,IAAM7C,GAAG,GAAG,IAAI7D,IAAJ,GAAW8D,OAAX,EAAZ;IACA,IAAM8C,OAAO,GAAGK,SAAS,GAAGpD,GAA5B;;IACA,IAAI+C,OAAO,GAAG,CAAd,EAAiB;MACf,KAAKH,eAAL,CAAqBC,YAArB,EAAmCE,OAAnC;IADF,OAEO;MACL,KAAKrF,UAAL,CAAgB,MAAhB;MACA,KAAKC,sBAAL;IACD;EAnPL;;EAAAK,OAsPER,UAtPF,GAsPE;IACE,IAAM8F,GAAG,GAAGnG,MAAM,CAACoC,YAAPpC,CAAoBmC,OAApBnC,CAA4B,YAA5BA,CAAZ;IACAA,MAAM,CAACoC,YAAPpC,CAAoBO,UAApBP,CAA+B,YAA/BA;IACAS,OAAO,CAAC2F,GAAR3F,CAAY;MAAE0F,GAAG,EAAHA;IAAF,CAAZ1F;;IACA,IAAI0F,GAAG,KAAK,IAAZ,EAAkB;MAChBnG,MAAM,CAACC,QAAPD,CAAgB7B,OAAhB6B,CAAwBmG,GAAxBnG;IACD;;IACD,KAAKQ,sBAAL;EA7PJ;;EAAA;AAAA","names":["AuthContext","React","createContext","undefined","useAuth","context","useContext","Error","withAuth","ComponentToWrap","WrappedComponent","props","authProps","displayName","name","AuthProvider","authService","children","Provider","value","base64URLEncode","str","toString","replace","sha256","buffer","createHash","update","digest","createPKCECodes","codeVerifier","randomBytes","codeChallenge","Buffer","from","createdAt","Date","codePair","toSnakeCase","split","join","toLowerCase","toUrlEncoded","obj","Object","keys","map","k","encodeURIComponent","AuthService","code","getCodeFromLocation","window","location","fetchToken","then","_this","restoreUri","e","removeItem","removeCodeFromLocation","console","warn","autoRefresh","startTimer","_proto","getUser","t","getAuthTokens","decoded","jwtDecode","id_token","length","pairs","pair","key","decodeURIComponent","href","base","search","newSearch","param","filter","keyAndVal","history","replaceState","state","getItem","localStorage","getPkce","pkce","JSON","parse","setAuthTokens","auth","refreshSlack","_this$props$refreshSl","now","getTime","expires_at","expires_in","setItem","stringify","isPending","isAuthenticated","logout","shouldEndSession","_this3","clientId","provider","logoutEndpoint","redirectUri","query","client_id","post_logout_redirect_uri","url","reload","login","_this5","authorize","authorizeEndpoint","scopes","audience","scope","responseType","codeChallengeMethod","isRefresh","_this7","clientSecret","contentType","tokenEndpoint","_this7$props$autoRefr","grantType","payload","refresh_token","fetch","headers","method","body","response","json","armRefreshTimer","refreshToken","timeoutDuration","timeout","clearTimeout","setTimeout","_this8","newRefreshToken","expiresAt","authTokens","uri","log"],"sources":["C:\\Users\\A'xenta R\\Desktop\\node_modules\\react-oauth2-pkce\\src\\AuthContext.tsx","C:\\Users\\A'xenta R\\Desktop\\node_modules\\react-oauth2-pkce\\src\\AuthProvider.tsx","C:\\Users\\A'xenta R\\Desktop\\node_modules\\react-oauth2-pkce\\src\\pkce.ts","C:\\Users\\A'xenta R\\Desktop\\node_modules\\react-oauth2-pkce\\src\\util.ts","C:\\Users\\A'xenta R\\Desktop\\node_modules\\react-oauth2-pkce\\src\\AuthService.ts"],"sourcesContent":["import React, { useContext, ReactElement } from 'react'\n\nimport { AuthServiceProps, AuthService } from './AuthService'\n\nexport type AuthContextProps = {\n  authService: AuthService\n}\n\nexport type AuthContextType = AuthContextProps | undefined\n\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(\n  undefined\n)\n\nexport const useAuth = (): AuthContextProps => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within a AuthProvider')\n  }\n  return context\n}\n\nexport function withAuth<T>(\n  ComponentToWrap: React.ComponentType<T & AuthServiceProps>\n): React.FC<T & AuthServiceProps> {\n  const WrappedComponent = (props: T & AuthServiceProps): ReactElement => {\n    const authProps = useAuth()\n    return <ComponentToWrap {...authProps} {...props} />\n  }\n  WrappedComponent.displayName =\n    'withAuth_' + (ComponentToWrap.displayName || ComponentToWrap.name)\n  return WrappedComponent\n}\n","import React, { ReactElement, ReactNode } from 'react'\n\nimport { AuthService } from './AuthService'\nimport { AuthContext } from './AuthContext'\n\ninterface AuthProviderProps {\n  children: ReactNode\n  authService: AuthService\n}\n\nexport const AuthProvider = (props: AuthProviderProps): ReactElement => {\n  const { authService, children } = props\n\n  return (\n    <AuthContext.Provider value={{ authService }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n","import { randomBytes, createHash } from 'crypto'\n\nexport type PKCECodePair = {\n  codeVerifier: string\n  codeChallenge: string\n  createdAt: Date\n}\n\nexport const base64URLEncode = (str: Buffer): string => {\n  return str\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n}\n\nexport const sha256 = (buffer: Buffer): Buffer => {\n  return createHash('sha256').update(buffer).digest()\n}\n\nexport const createPKCECodes = (): PKCECodePair => {\n  const codeVerifier = base64URLEncode(randomBytes(64))\n  const codeChallenge = base64URLEncode(sha256(Buffer.from(codeVerifier)))\n  const createdAt = new Date()\n  const codePair = {\n    codeVerifier,\n    codeChallenge,\n    createdAt\n  }\n  return codePair\n}\n","export const toSnakeCase = (str: string): string => {\n  return str\n    .split(/(?=[A-Z])/)\n    .join('_')\n    .toLowerCase()\n}\n\nexport const toUrlEncoded = (obj: {}): string => {\n  return Object.keys(obj)\n    .map(\n      (k) =>\n        encodeURIComponent(toSnakeCase(k)) + '=' + encodeURIComponent(obj[k])\n    )\n    .join('&')\n}\n","/* eslint-disable @typescript-eslint/camelcase */\nimport { createPKCECodes, PKCECodePair } from './pkce'\nimport { toUrlEncoded } from './util'\n\nimport jwtDecode from 'jwt-decode'\n\nexport interface AuthServiceProps {\n  clientId: string\n  clientSecret?: string\n  contentType?: string\n  location: Location\n  provider: string\n  authorizeEndpoint?: string\n  tokenEndpoint?: string\n  logoutEndpoint?: string\n  audience?: string\n  redirectUri?: string\n  scopes: string[]\n  autoRefresh?: boolean\n  refreshSlack?: number\n}\n\nexport interface AuthTokens {\n  id_token: string\n  access_token: string\n  refresh_token: string\n  expires_in: number\n  expires_at?: number // calculated on login\n  token_type: string\n}\n\nexport interface JWTIDToken {\n  given_name: string\n  family_name: string\n  name: string\n  email: string\n}\n\nexport interface TokenRequestBody {\n  clientId: string\n  grantType: string\n  redirectUri?: string\n  refresh_token?: string\n  clientSecret?: string\n  code?: string\n  codeVerifier?: string\n}\n\nexport class AuthService<TIDToken = JWTIDToken> {\n  props: AuthServiceProps\n  timeout?: number\n\n  constructor(props: AuthServiceProps) {\n    this.props = props\n    const code = this.getCodeFromLocation(window.location)\n    if (code !== null) {\n      this.fetchToken(code)\n        .then(() => {\n          this.restoreUri()\n        })\n        .catch((e) => {\n          this.removeItem('pkce')\n          this.removeItem('auth')\n          this.removeCodeFromLocation()\n          console.warn({ e })\n        })\n    } else if (this.props.autoRefresh) {\n      this.startTimer()\n    }\n  }\n\n  getUser(): {} {\n    const t = this.getAuthTokens()\n    if (null === t) return {}\n    const decoded = jwtDecode(t.id_token) as TIDToken\n    return decoded\n  }\n\n  getCodeFromLocation(location: Location): string | null {\n    const split = location.toString().split('?')\n    if (split.length < 2) {\n      return null\n    }\n    const pairs = split[1].split('&')\n    for (const pair of pairs) {\n      const [key, value] = pair.split('=')\n      if (key === 'code') {\n        return decodeURIComponent(value || '')\n      }\n    }\n    return null\n  }\n\n  removeCodeFromLocation(): void {\n    const [base, search] = window.location.href.split('?')\n    if (!search) {\n      return\n    }\n    const newSearch = search\n      .split('&')\n      .map((param) => param.split('='))\n      .filter(([key]) => key !== 'code')\n      .map((keyAndVal) => keyAndVal.join('='))\n      .join('&')\n    window.history.replaceState(\n      window.history.state,\n      'null',\n      base + (newSearch.length ? `?${newSearch}` : '')\n    )\n  }\n\n  getItem(key: string): string | null {\n    return window.localStorage.getItem(key)\n  }\n  removeItem(key: string): void {\n    window.localStorage.removeItem(key)\n  }\n\n  getPkce(): PKCECodePair {\n    const pkce = window.localStorage.getItem('pkce')\n    if (null === pkce) {\n      throw new Error('PKCE pair not found in local storage')\n    } else {\n      return JSON.parse(pkce)\n    }\n  }\n\n  setAuthTokens(auth: AuthTokens): void {\n    const { refreshSlack = 5 } = this.props\n    const now = new Date().getTime()\n    auth.expires_at = now + (auth.expires_in + refreshSlack) * 1000\n    window.localStorage.setItem('auth', JSON.stringify(auth))\n  }\n\n  getAuthTokens(): AuthTokens {\n    return JSON.parse(window.localStorage.getItem('auth') || '{}')\n  }\n\n  isPending(): boolean {\n    return (\n      window.localStorage.getItem('pkce') !== null &&\n      window.localStorage.getItem('auth') === null\n    )\n  }\n\n  isAuthenticated(): boolean {\n    return window.localStorage.getItem('auth') !== null\n  }\n\n  async logout(shouldEndSession: boolean = false): Promise<boolean> {\n    this.removeItem('pkce')\n    this.removeItem('auth')\n    if (shouldEndSession) {\n      const { clientId, provider, logoutEndpoint, redirectUri } = this.props;\n      const query = {\n        client_id: clientId,\n        post_logout_redirect_uri: redirectUri\n      }\n      const url = `${logoutEndpoint || `${provider}/logout`}?${toUrlEncoded(query)}`\n      window.location.replace(url)\n      return true;\n    } else {\n      window.location.reload()\n      return true\n    }\n  }\n\n  async login(): Promise<void> {\n    this.authorize()\n  }\n\n  // this will do a full page reload and to to the OAuth2 provider's login page and then redirect back to redirectUri\n  authorize(): boolean {\n    const { clientId, provider, authorizeEndpoint, redirectUri, scopes, audience } = this.props\n\n    const pkce = createPKCECodes()\n    window.localStorage.setItem('pkce', JSON.stringify(pkce))\n    window.localStorage.setItem('preAuthUri', location.href)\n    window.localStorage.removeItem('auth')\n    const codeChallenge = pkce.codeChallenge\n\n    const query = {\n      clientId,\n      scope: scopes.join(' '),\n      responseType: 'code',\n      redirectUri,\n      ...(audience && { audience }),\n      codeChallenge,\n      codeChallengeMethod: 'S256'\n    }\n    // Responds with a 302 redirect\n    const url = `${authorizeEndpoint || `${provider}/authorize`}?${toUrlEncoded(query)}`\n    window.location.replace(url)\n    return true\n  }\n\n  // this happens after a full page reload. Read the code from localstorage\n  async fetchToken(code: string, isRefresh = false): Promise<AuthTokens> {\n    const {\n      clientId,\n      clientSecret,\n      contentType,\n      provider,\n      tokenEndpoint,\n      redirectUri,\n      autoRefresh = true\n    } = this.props\n    const grantType = 'authorization_code'\n\n    let payload: TokenRequestBody = {\n      clientId,\n      ...(clientSecret ? { clientSecret } : {}),\n      redirectUri,\n      grantType\n    }\n    if (isRefresh) {\n      payload = {\n        ...payload,\n        grantType: 'refresh_token',\n        refresh_token: code\n      }\n    } else {\n      const pkce: PKCECodePair = this.getPkce()\n      const codeVerifier = pkce.codeVerifier\n      payload = {\n        ...payload,\n        code,\n        codeVerifier\n      }\n    }\n\n    const response = await fetch(`${tokenEndpoint || `${provider}/token`}`, {\n      headers: {\n        'Content-Type': contentType || 'application/x-www-form-urlencoded'\n      },\n      method: 'POST',\n      body: toUrlEncoded(payload)\n    })\n    this.removeItem('pkce')\n    let json = await response.json()\n    if (isRefresh && !json.refresh_token) {\n      json.refresh_token = payload.refresh_token\n    }\n    this.setAuthTokens(json as AuthTokens)\n    if (autoRefresh) {\n      this.startTimer()\n    }\n    return this.getAuthTokens()\n  }\n\n  armRefreshTimer(refreshToken: string, timeoutDuration: number): void {\n    if (this.timeout) {\n      clearTimeout(this.timeout)\n    }\n    this.timeout = window.setTimeout(() => {\n      this.fetchToken(refreshToken, true)\n        .then(({ refresh_token: newRefreshToken, expires_at: expiresAt }) => {\n          if (!expiresAt) return\n          const now = new Date().getTime()\n          const timeout = expiresAt - now\n          if (timeout > 0) {\n            this.armRefreshTimer(newRefreshToken, timeout)\n          } else {\n            this.removeItem('auth')\n            this.removeCodeFromLocation()\n          }\n        })\n        .catch((e) => {\n          this.removeItem('auth')\n          this.removeCodeFromLocation()\n          console.warn({ e })\n        })\n    }, timeoutDuration)\n  }\n\n  startTimer(): void {\n    const authTokens = this.getAuthTokens()\n    if (!authTokens) {\n      return\n    }\n    const { refresh_token: refreshToken, expires_at: expiresAt } = authTokens\n    if (!expiresAt || !refreshToken) {\n      return\n    }\n    const now = new Date().getTime()\n    const timeout = expiresAt - now\n    if (timeout > 0) {\n      this.armRefreshTimer(refreshToken, timeout)\n    } else {\n      this.removeItem('auth')\n      this.removeCodeFromLocation()\n    }\n  }\n\n  restoreUri(): void {\n    const uri = window.localStorage.getItem('preAuthUri')\n    window.localStorage.removeItem('preAuthUri')\n    console.log({ uri })\n    if (uri !== null) {\n      window.location.replace(uri)\n    }\n    this.removeCodeFromLocation()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}